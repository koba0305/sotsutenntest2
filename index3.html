<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Map</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        #map-container {
            width: 80vw;
            height: 80vh;
            background-color: #0000ff;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            overflow: hidden;
        }
        #map {
            width: 1000px;
            height: 1000px;
            background-image: linear-gradient(45deg, #ffffff 25%, #0000ff 25%, #0000ff 50%, #ffffff 50%, #ffffff 75%, #0000ff 75%, #0000ff);
            background-size: 50px 50px;
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: center;
        }
    </style>
</head>
<body>
    <div id="map-container">
        <div id="map"></div>
    </div>

    <script>
        const map = document.getElementById('map');
        const container = document.getElementById('map-container');

        let isDragging = false;
        let lastX = 0;
        let lastY = 0;
        let offsetX = 0;
        let offsetY = 0;
        let scale = 1;

        // Function to set the map position
        function updateMapPosition(dx, dy) {
            offsetX += dx;
            offsetY += dy;
            map.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
        }

        // Mouse events for dragging
        map.addEventListener('mousedown', (event) => {
            isDragging = true;
            lastX = event.clientX;
            lastY = event.clientY;
            map.style.cursor = 'grabbing';
        });

        window.addEventListener('mousemove', (event) => {
            if (!isDragging) return;
            const dx = event.clientX - lastX;
            const dy = event.clientY - lastY;
            updateMapPosition(dx, dy);
            lastX = event.clientX;
            lastY = event.clientY;
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
            map.style.cursor = 'grab';
        });

        // Scroll event for zooming
        container.addEventListener('wheel', (event) => {
            event.preventDefault();
            const zoomFactor = event.deltaY < 0 ? 1.1 : 0.9;
            const rect = map.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();

            // Calculate zoom center
            const mouseX = event.clientX - containerRect.left;
            const mouseY = event.clientY - containerRect.top;
            const mapX = (mouseX - offsetX) / scale;
            const mapY = (mouseY - offsetY) / scale;

            // Update scale
            scale = Math.min(5, Math.max(0.5, scale * zoomFactor));

            // Adjust offset to keep zoom centered
            offsetX = mouseX - mapX * scale;
            offsetY = mouseY - mapY * scale;

            map.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
        });

        // Touch events for dragging and pinch zoom
        let touchStartDist = 0;
        let touchStartScale = scale;

        container.addEventListener('touchstart', (event) => {
            if (event.touches.length === 1) {
                isDragging = true;
                lastX = event.touches[0].clientX;
                lastY = event.touches[0].clientY;
            } else if (event.touches.length === 2) {
                isDragging = false;
                touchStartDist = Math.hypot(
                    event.touches[0].clientX - event.touches[1].clientX,
                    event.touches[0].clientY - event.touches[1].clientY
                );
                touchStartScale = scale;
            }
        });

        container.addEventListener('touchmove', (event) => {
            if (isDragging && event.touches.length === 1) {
                const dx = event.touches[0].clientX - lastX;
                const dy = event.touches[0].clientY - lastY;
                updateMapPosition(dx, dy);
                lastX = event.touches[0].clientX;
                lastY = event.touches[0].clientY;
            } else if (event.touches.length === 2) {
                const currentDist = Math.hypot(
                    event.touches[0].clientX - event.touches[1].clientX,
                    event.touches[0].clientY - event.touches[1].clientY
                );
                const zoomFactor = currentDist / touchStartDist;
                scale = Math.min(5, Math.max(0.5, touchStartScale * zoomFactor));

                const rect = map.getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();
                const centerX = (event.touches[0].clientX + event.touches[1].clientX) / 2 - containerRect.left;
                const centerY = (event.touches[0].clientY + event.touches[1].clientY) / 2 - containerRect.top;

                const mapX = (centerX - offsetX) / touchStartScale;
                const mapY = (centerY - offsetY) / touchStartScale;

                offsetX = centerX - mapX * scale;
                offsetY = centerY - mapY * scale;

                map.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
            }
        });

        container.addEventListener('touchend', () => {
            isDragging = false;
        });
    </script>
</body>
</html>
